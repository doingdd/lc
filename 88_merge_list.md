# 88. 合并两个有序数组

## case



```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。

输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

```

## 思路

这道题与21.合并链表相似，改成了合并数组，并且需要原地修改数组1，由于是原地修改，所以不适用从前向后的遍历，因为遍历的过程可能破坏原数组，导致后面的遍历元素错乱。所以，可以采用从后向前的遍历方式，因为nums1的后面已经预留了足够的空间，可以实时修改，而不影响遍历

实现的方式是三个指针，分别记录nums1,nums2的当前元素，和新序列nums1的当前元素位置



```python
def merge(self, nums1, m, nums2, n): 
    """ 
    :type nums1: List[int]
    :type m: int
    :type nums2: List[int]
    :type n: int
    :rtype: None Do not return anything, modify nums1 in-place instead.
    """
    i,j = m-1,n-1
    k = m+n-1 
    while i>=0 and j>=0:
        if nums1[i]>nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
            
        k -= 1
        
    if j >=0:
        nums1[:k+1] = nums2[:j+1]
```

## 总结

这道题再掌握了21题之后，就没什么难度了，核心注意：

1. 从后向前遍历，需要维护三个指针
2. 判断某一个序列遍历完成的情况，即退出while循环后，如果i>=0，其实是nums1还没有遍历完成，但是由于最终的结果也存在nums1中，故不用处理i>=0的情况，只处理j>=0也就是nums2没遍历完成的情况即可(将没遍历完的部分直接赋给nums1的对应位置)