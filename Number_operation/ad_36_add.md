# 36进制字符串相加



## case

```python
case = [
    ["1b","2x"],
    ["12","24"],
    ["1","1"],
    ["0","1"],
    ["zz","aa"]
]
```



## 思路

这道题和字符串相加思路整体是一致的，只不过换成了36进制，相当于加了一些转换的处理，整体方式仍然是从后向前遍历，设置一个进位标志，每一位相加之和取余为当前位结果，取除为进位结果，当然，如果是36进制的，需要先将每一位转化成10进制，相加后再/36或者%36，然后再转换回36进制

这里先准备好转换函数，toInt为36进制的字符串转换成10进制的int，toChar反之

比如toInt的时候，如果一个字符是0-9，那么直接int(str), 如果是a-z,那么其实对应的十进制是10-25，这里的转换方式是ord('x')-ord('a')+10, 然后，每一位都要乘以当前位的乘数，比如十进制数：123 = 1*10^2 + 2\*10^1 + 3\*10^0

```python
def toInt(x):
    y = 0
    c = 0
    for i,v in enumerate(x[::-1]):
        if v.isdigit():
            y += (36**i * int(v))
        else:
            y += (36**i *(ord(v) - ord('a') + 10))

    return y

def toChar(x):
    y = ''
    while (x / 36) >= 0:
        if x == 0 and x%36 == 0:
            break

        v = str(x%36) if (x%36)<10 else chr(x%36 - 10 + ord('a'))
        y = v + y
        x /= 36

    return y
```

然后是核心逻辑，两个指针分别从后遍历两个字符串，把每一个字符经过36进制和10进制之间的转换之后，再相加，这里的v表示的是当前位，c表示的进位，这里有一个思想是，当两个字符串长度不相等时，一定有一个字符串先遍历完成，这是遍历完成的字符需要补0

最后，再判断下是否有余留的进位，如果有的话需要加上进位

```
def add36(a,b):
    '''
        type a,b: str
        type res: str
    '''

    i,j = len(a)-1 ,len(b) -1
    c = 0
    res = ''
    while i>=0 or j >=0:
        x = toInt(a[i]) if i >=0 else 0
        y = toInt(b[j]) if j >=0 else 0
        v = toChar((x + y + c) % 36)
        c = (x+y+c)/36
        res = v + res
        i -= 1
        j -= 1

    if c:
        res = str(c) + res
    return res

```





```python
for i in case:
    a = toInt(i[0])
    b = toInt(i[1])

    print i,a,b,
    print add36(*i),toInt(add36(*i))
    
['1b', '2x'] 47 105 48 152
['12', '24'] 38 76 36 114
['1', '1'] 1 1 2 2
['0', '1'] 0 1 1 1
['zz', 'aa'] 1295 370 1a9 1665

```



## 总结

这道题有几点需要注意：

1. 36进制和10进制的转换思路，利用1*10^2 + 2\*10^1 + 3\*10^0 = 123的思想，转换成10进制；而10进制转换回36进制时，则相反，利用相除的思想
2. 某一个字符串遍历完成时注意补零
3. 余留进位标志的处理