# 695. 岛屿的最大面积

## 用例设计

```
case = [
 [
  [0,0,1,0,0,0,0,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,1,1,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,0,1,1,0,0,1,0,1,0,0],
  [0,1,0,0,1,1,0,0,1,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,0,0,0,0,0,0,1,1,0,0,0,0]
 ],
 [[0,0,0,0,0,0,0,0]],
 [
  [0,1,0,0],
  [1,1,1,0],
  [0,1,0,0],
  [1,1,0,0]
 ]
]
```



## 思路及实现

本题的思路和所有网格类或者岛屿类的问题比较一致，首先网格类的深度遍历回顾：

* 停止条件：遍历的节点超出了网格，或者遍历到不是陆地(非1)则停止

* 遍历方式：仍然是左、右、上、下四个方向遍历，本题是要求面积，那么逻辑处理部分，应该在dfs深度遍历的同时进行

比如，只要遍历到某一个节点，并且没有触发停止条件，则应该将当前节点的面积(为1)，加上它能探索到的其它节点的面积，并返回这个总面积

而停止条件时返回面积0

```python
def max_area(grid):
    m,n = len(grid),len(grid[0])
    def inArea(i,j):
        return 0 <= i < m and 0 <= j < n

    def dfs(i,j):
        if not inArea(i,j) or grid[i][j] != 1:
            return 0
				##标记探测过的节点
        grid[i][j] = 2
        ## 当前的面积为1，加上其关联的节点面积，然后返回，可以理解为这个area为当前节点以及它所有下级的节点面积之和，遍历到停止条件时，它的area则为0，遍历到没有下级的节点时它的面积为1
        area = 1
        area += dfs(i-1,j)
        area += dfs(i+1,j)
        area += dfs(i,j-1)
        area += dfs(i,j+1)

        return area

    area_list = []
    ## 主循环中，判断到陆地之后则开启一轮dfs，并将dfs的结果保存，当然也可以直接用临时变量存下最大的area
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                area = dfs(i,j)
                area_list.append(area)

    return max(area_list) if area_list else 0

for i in case:
    print 'case is {0}'.format(i),
    print 'reuslt is {0}'.format(max_area(i))

```



## 总结

岛屿问题的核心思路，如果遇见过之后，其实记忆起来还是很简单的，个人认为真正难的是它的逻辑处理部分，也就是什么时候进行逻辑处理。

比如，

* 在求岛屿个数时，岛屿个数可以抽象成dfs遍历的次数，那么只要有一次dfs，就需要count+1,这是在**主循环中处理逻辑**，dfs**不需要返回值**，只计数即可

* 在求岛屿周长时，岛屿周长增加的条件，是某一块陆地的某一条边遇到了边缘，也就是一块陆地四个方向，只有某一个方向上到了边界或者遇到水，那它的周长才+1，这里的+1是在dfs的终止条件中做的，也就是grid[i][j\] 超界或==0(==2时不算)时，才+1，这是在**终止条件中处理逻辑**，并在循环中累加总和，所以dfs**需要返回值**
* 在本题中，求岛屿面积，那只要探索到陆地，面积则需要+1，当终止时，面积为0，并且在循环中，将子循环中的结果累加，属于在**遍历中处理逻辑**，所以也需要**dfs返回一个累加值**，当然这个累加值和求周长时不同，它来源于“遍历”，而求周长来源于"边界”。

总结这三道岛屿题，可以看到我们需要思考的，更多是什么时候处理逻辑的问题，终止条件时的逻辑是什么？是0还是1？循环的过程中逻辑是什么？是否需要进行累加？