# 463.岛屿周长

## 用例设计

有效等价类：

```
grid = [
	[0,1,0,0],
	[1,1,1,0],
	[0,1,0,0],
	[1,1,0,0]
]
输出为16
```

特殊值：

```python
grid = [[1]]
输出为4
grid = [[1,0]]
输出为4
```

```python
case = [
  [
		[0,1,0,0],
		[1,1,1,0],
		[0,1,0,0],
		[1,1,0,0]
	],
  [[1]],
  [[1,0]],
  [
  	[0,1,0,0],
		[1,1,1,0],
		[0,0,0,0],
		[0,0,0,0]
  ]
]
```



## 思路及解答

首先，岛屿问题，或者说网格问题，经典的dfs深度优先思路先考虑起来，而且注意本题中，岛屿的个数有且仅有一个，也就是不存在都是0，或者说有多个岛屿的情况，而且，不存在”空心“，也就是”湖“的情况。

再回顾一下网格类问题dfs的两个要点：

* 停止条件，或者说是基线条件：超出网格范围，或者遇到了”0“
* 如何遍历：分别遍历当前节点的左右上下，而题目中的要求，都藏在如何再遍历的同时处理附加信息上

本题中，为了求总周长，需要总结周长与陆地的动态关系，可以看出，只要第一次探测到一块陆地，可以默认周长就增加了4，而一旦在这块陆地上开启了dfs，那么每个方向上的探索，只要遇到陆地，则将当前周长-1，并加上新陆地的默认周长3。

```
def perimeter(grid):
    m,n = len(grid),len(grid[0])
    p = 0
    def inArea(i,j):
        return 0 <= i < m and 0 <= j < n
	  ## dfs的核心：判断啥时候停止，染色遍历过的防止重复，遍历时处理核心逻辑
    def dfs(i,j):
        if not inArea(i,j) or grid[i][j] == 0:
            return 1

        if grid[i][j] == 2:
            return 0

        grid[i][j] = 2

        return dfs(i-1,j) +\
               dfs(i+1,j) +\
               dfs(i,j-1) +\
               dfs(i,j+1)

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                return dfs(i,j)

```



## 总结

本题中有一个限制条件是有且仅有一块岛屿，所以，在主循环中，只要找到了一块陆地，那么从这块陆地开始dfs，一定可以获得整个岛屿的周长，所以可以直接return dfs(i,j)

另外，这道题的难点在于怎么计算周长，如果使用上面思路中的方法，代码实现起来不够简洁，这里的实现采用了标准答案中的思路：

即一块陆地有四条边，每条边的方向上只有遇到了0，或者出界了，才认为这条边给周长的贡献成功，可以给周长+1，这样，在dfs的停止条件中，一旦遇到0或者出界时，return 1，遇到2时，return 0

然后，dfs函数需要return的是所有四条边返回的”贡献“之和

