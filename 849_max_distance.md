# 849.到最近人的最大举例



给你一个数组 seats 表示一排座位，其中 seats[i] = 1 代表有人坐在第 i 个座位上，seats[i] = 0 代表座位 i 上是空的（下标从 0 开始）。

至少有一个空座位，且至少有一人已经坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

## case



```python
输入：seats = [1,0,0,0,1,0,1]
输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 

输入：seats = [1,0,0,0]
输出：3
解释：
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。

输入：seats = [0,1]
输出：1
case = [
  [1,0,0,0,1,0,1],
  [1,0,0,0],
  [0,1]
]
```



## 思路

这道题的基本解法是多次遍历的方式，第一次遍历，记录当前位置与其左边有人的位置的最小距离，第二次记录右边；第三次将左右两遍的距离取最小值，即得到每个位置，离他最近的人的距离；并在全局维护这个距离的最大值即可

翻译成机器语言，就是求每个0，与其最近的1的距离，因为距离包括左和右，所以需要遍历两次

这里用left维护左距离，right维护右距离

```python
def maxDistToClosest(seats):
    """
    :type seats: List[int]
    :rtype: int
    """
    l = len(seats)
    left = [l] * l
    right = [l] * l

    for i in range(l):
        if seats[i] == 1:
            left[i] = 0
        elif i > 0:
            left[i] = left[i-1] + 1

    for i in range(l-1,-1,-1):
        if seats[i] == 1:
            right[i] = 0
        elif i < l - 1:
            right[i] = right[i+1] + 1

    distance = 0
    for i in range(l):
        distance = max(min(left[i],right[i]),distance)

    return distance

case = [
  [1,0,0,0,1,0,1],
  [1,0,0,0],
  [0,1]
]

for i in case:
    print(i,maxDistToClosest(i))

```

## 总结

这道题有两点需要注意：

1. left，right这两个数组初始值的设定，需要考虑的是最左侧或者最右侧为空座位(0)时，这是的left[0]或者right[l-1]其实应该是一个最大值，而不应该是0，因为默认再往左或者往右就没人了，距离应该为无限大；所以本题中使用长度l来作为初始值，其实实现了“无限大”这个概念，而且，再遍历过程中，要对边界index做判断，如果有人(为1)还好，直接置为0，但是如果为空座位(为0)，则维持初始值不变，不应该再对其赋值
2. 第二次遍历为倒序遍历，这里注意range的写法range(start,end,step), end值本身并不包含，所以应该为range(l-1,-1,-1)