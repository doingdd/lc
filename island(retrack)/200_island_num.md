# 200.岛屿数量

## 用例设计

* 输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
  ]
  输出：1
  
* 输入：grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
  ]
  输出：3

  岛屿的定义：1为陆地，0为水，上下左右四个方向上没有1，则该陆地就是岛屿

```python
case = (
	[
		["1","1","1","1","0"],
		["1","1","0","1","0"],
		["1","1","0","0","0"],
		["0","0","0","0","0"]
	],
  [
  	["1","1","0","0","0"],
  	["1","1","0","0","0"],
  	["0","0","1","0","0"],
  	["0","0","0","1","1"]
	]
)
```



## 思路及解答

这道题，如果没有事先了解过DFS(深度遍历)，二叉树的深度遍历，应该是没办法直接想出答案的，这里就按照leetcode上的解题思路，自我总结一下吧：

首先，DFS深度遍历，都有两个组成部分，其实也是递归的组成部分：基线条件，深度遍历，举例，二叉树的深度遍历：

```python
def dfs(root):
  ## 基线条件也就是停止条件，root必须不为空，为空则停止遍历，return
  if not root:
    return
  ##深度遍历方式，访问两个相邻结点：左子结点、右子结点
  dfs(root.left)
  dfs(root.right)
  
```

可以看到，其实深度遍历的核心就是两个：啥时候停止，怎么访问相邻节点

对于二叉树来说，相邻节点时左右两个子树，而对于网格类问题来说，相邻的节点有四个：左、右、上、下

回到本题，或者说所有的岛屿问题，解决两个问题，就有了整体框架的思路：

* 啥时候停止： 当遍历到`网格外`时,或者碰到`水`了(即0)，就停止(相当于二叉树遍历中的root=None)
* 怎么访问相邻接点: 设i,j分别为行和列的index，相邻则是：(i-1,j),(i+1,j),(i,j-1),(i,j+1)

当然，还有一个非常重要的问题，就是重复遍历的问题，如果遍历时不做标记，则会进入到死循环中，这是因为，网格问题和二叉树问题不同，二叉树本质上是个`有向无环图`,网格问题是个`有环图`,所以，必须要在遍历grid[i][j\]的时候将其值做修改，改成0或者改成2都可以，本题中改成2，那么遍历停止的条件就不是碰到0，而是碰到`非1`的数字

```python
def numIsland(grid):
    '''type grid: List[List[str]]
       type rt: int
    '''
    def inArea(i,j):
        return i>=0 and j>=0 and i<m and j<n

    def dfs(i,j):
        #if not inArea(i,j):
        if not 0 <= i < m or not 0 <= j < n:
            return
        if grid[i][j] != "1":
            return

        grid[i][j] = 2
        dfs(i-1,j)
        dfs(i+1,j)
        dfs(i,j-1)
        dfs(i,j+1)


    if not grid:
        return 'Invalid'

    count = 0
    m,n = len(grid),len(grid[0])
    for i in range(m):
        for j in range(n):
            if grid[i][j] == "1":
                dfs(i,j)
                count += 1

    return count
```



## 总结

这种题目就属于没耍过肯定不会的问题，没啥可解释的，就是遇见了多总结，并且记住吧，本题实现上需要注意的是：

1. 大遍历中，什么时候开启dfs？什么时候将岛屿数量+1是需要思考的，其实就是当有一个陆地的可能时，就开启遍历(可以理解成探路，探地图)，当探到边界时，就停止，然后岛屿数量+1
2. 探路时，什么时候停止？也就是dfs中，i和j的边界判断，以及当前值的判断(!=1，而不是==0，因为我们染色时，将谈过的路改写成2了，探过的路也不能再探)
3. 染色的问题，本题中，其实染色成0也可以，但是为了区分和“水“的区别，改成2，方便以后碰到其它岛屿问题时，处理上的统一性，当然，必须要在进行”继续探路“操作之前染色，否则就会死循环，导致栈溢出

