# 123. 买卖股票的最佳时机3

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



## case

```python
case = [
        [3,3,5,0,0,3,1,4],
        [1,2,3,4,5],
        [7,6,4,3,1]
        ]
```



## 思路

这道题是股票系列比较难的题，因为限制了只能买卖两次，需要考虑的情况比较多，在每天结束时，状态严格意义上有5种(第一种可忽略):

1. 未持有，未买入(未进行任何操作)

2. 持有，买入了一次，定义为buy1
3. 持有，买入了两次, buy2
4. 未持有，卖出了一次,sell1
5. 未持有，卖出了两次, sell2

本题的解法比较高端，虽然是动态规划，但是没有用到传统的dp table，而是用四个变量来实现(其实也算是table了)，变量的值就是当前状态的收益

1. 那每种状态先考虑初始值，buy1，buy2的初始值，也就是第一天的时候，只能为-prices[0]，因为第一天买入的收益肯定是负的第一天的价格
2. sell1,sell2的初始值一定为0，因为第一天买卖都不赚钱

注意，上述的初始值可以看到，它的思路实际上是把买和卖拆开来看，同时，相互之间还会有联系，这种做法是建立再可以当天买卖的前提上的，然后考虑四个状态的转移

1. Buy1, max(buy1,-i); 为什么是用上一次的buy1 和当前的价格的负数取最大值？为什么不用当前的sell2-i?

   这里一定注意理解，buy1它仅代表一个状态，就是只买了一次，还没卖过的状态，所以在遍历到当前的i时，它是一种假设，假设我到了i的时候才第一次买，那么和上一次的假设(i-1)时的收益，哪个大就取哪个，作为当前的最大收益。。

   其实这个buy1没有啥实际意义，包括sell1,buy2等都是，它都是为了推导出sell2服务的，也就是当前时间，加入买卖两次完成的最大收益

2. Sell1,如果理解了buy1的计算，后面的其实就比较顺了，sell1一定是等于Buy1+prices[i]和上一次sell1的最大值

3. Buy2, max(buy2,sell1-i)，同理，第二次买的话，一定是第一次买卖的结果减去第二次买的成本

4. Sell2, max(sell2,buy2+i), 同理，第二次卖的话，应该等于第二次买时的成本+当前价格

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        buy1 = buy2 = -prices[0]
        sell1 = sell2 = 0
        for i in prices[1:]:
            buy1 = max(buy1,-i)
            sell1 = max(sell1,buy1+i)
            buy2 = max(buy2,sell1-i)
            sell2 = max(sell2,buy2+i)
        
        return sell2 

```

```python
[3, 3, 5, 0, 0, 3, 1, 4] 6
[1, 2, 3, 4, 5] 4
[7, 6, 4, 3, 1] 0
```



## 总结

这个解法只能用一句话形容：代码越简单的有时候理解越困难。。。

它没有用到dp数组来存储，而是直接用四个变量，然后再遍历的时候合并了比大小的逻辑，取max，每个状态的当前值还互相有关联，只能说死记硬背而后寻求理解吧，记忆的点：

1. 一共四个状态，buy1,buy2,sell1,sell2
2. 四个状态的初始值，买的等于负的价格，卖的等于0
3. 四个状态的转移，除了buy1这个特殊，等于当前价格的负数外，其余几个状态都由上一个状态推导而来
4. 最后的返回值是sell2,因为sell2已经在遍历中维护成了最大值，也包含了sell1的结果，所以一定是最终值

股票类问题，由买卖一次、无限买卖到只能买卖两次，难度逐渐加大，掌握套路即可