# 32. 最长的有小括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

## case

```python
case = [
    "(()",
    ")()())",
    "()",
    "((())))",
    "()(())",
    "()(()",
    ""
        ]
for i in case:
    print i,max_brackets(i)
```



## 思路

这道题虽然也是括号类问题，但是和`20.有小括号`,`22.括号生成`都不太一样，这道题的解法有好几个，本文采用了动态规划的思路

题目的要求是**连续**的子串，可以采用**以当前字符为结尾的**的方式构建动态规划的dp数组，所以本题中dp数组表示的是以当前字符为结尾的，符合要求的有效括号的长度，那怎么从dp[i-1]推到出dp[i]呢？

1. 注意观察，首先当前字符如果为左括号`(`，那么以左括号结尾的符合条件的子字符串一定是0，以为不管前面的子串有多少满足条件，只要结尾是`(`,它一定就不符合条件了
2. 如果s[i]是右括号，这个就比较复杂了，需要考虑多种情况
   * s[i]是右括号，s[i-1]是左括号，它配对成功了，那么dp[i] = d[i-2] + 2，也就是当前位的前两位的结果，加上新配对的2，就是当前dp[i]的值，即有效长度
   * s[i]是右括号，s[i-1]不是左括号，他也是右括号，也就是`))`这，这时要找到与之配对的左括号，它左括号的索引为i-dp[i-1]-1,这里注意理解，举例比如`()(())`这种字符，最后一位就是这种情况，这时i=5，dp[i-1]等于2，它配对的左括号索引为5-2-1 = 3，s[3]就是它的配对左括号`(`。 找到了配对的括号之后，判断它是不是左括号，是的话dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2], 后面的一串`dp[i-dp[i-1]-2]`是为了补齐最开始的两个括号的长度；不是左括号，那dp[i]就是0了
3. 精髓：2中的两种情况，甚至加上1的情况，在实现时可以统一实现，首先，将dp初始值全部设成0；其次，当前为右括号，且s[i-dp[i-1]-1]=='(' 时，才处理dp[i]，这里s[i-dp[i-1]-1]实际涵盖了两种情况，一种是s[i-1]为左括号，那由于dp[i-1]==0，s[i-dp[i-1]-1] 退化成s[i-1]；另一种s[i-1]为右括号，那dp[i-1]就有可能不为0了，s[i-dp[i-1]-1] 就会找到与i配对的那个位置，配对的位置必须为左括号才处理dp[i]
4. 精髓续: 在找到了处理条件之后，处理的方式：dp[i] = dp[s-dp[i-1]-2] + dp[i-1] + 2, 第一部分` dp[s-dp[i-1]-2] `是配对括号之前的和，需要累加，第二部分和第三部分`dp[i-1]+2`就是涵盖了两种情况的，一种是`()`，一种是`(())`

```python
def max_brackets(s):
    l = len(s)
    dp = [0]*l
    if not s:
        return 0

    for i in range(l):
        if s[i] == ')':
            if i-dp[i-1]-1 >=0 and s[i-dp[i-1]-1] == '(':
                dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]

    return max(dp)
```

```python
(() 2
)()()) 4
() 2
((()))) 6
()(()) 6
()(() 2
(()))())( 8
```



## 总结

这道题的很多解法，本题采用的动态规划的方式

1. `i-dp[i-1]-1`是当前右括号`)`对应的左括号`(`的位置
2. 在判断是否要处理dp[i]时，有几个隐含条件，一是对应的左括号的位置必须大于0，假如())这种是要排除掉；二是对应的位置必须是左括号，比如)())这种就排除掉了
3. 判断通过后，处理时要加上对应的左括号的位置之前的累加长度，也就是dp[s-dp[i-1]-1-1]就是减了两次1
4. 本题的动态规划思路是典型的`以当前字符结尾的`的动态规划，多多记忆吧