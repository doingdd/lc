# 1143.

## 用例

```python
case = [
  ["abcde","ace"],
  ["abc","abc"],
  ["abc","def"],
  ["","a"],
  ["",""],
  ["a","a"],
  ["aaaa"]
]
```



## 思路

对于两个字符串求子序列的问题，都是两个指针i和j分别再两个字符串上移动，大概率是动态规划的思路

动态规划也要解决两个问题：dp数组标志的含义，以及状态转移方程

本题中，dp[i][j]可以表示，在第i和第j这个位置上，两个字符串的最大子字符串的长度；那这个长度是哪里来的呢：是从前一个位置转化来的，如果s1[i]==s2[j],那么这个元素肯定在公共子字符串里，那么dp[i][j]=dp[i-1][j-1]+1, 如果不相等，有三种情况，s1[i]在子字符串里，s2[j]不在；s1[i]不在，s2[j]在；二者都不在，这时，dp[i][j]可以取dp[i][j-1]和dp[i-1][j]的最大值

同时，这中累加的方式，需要有一个初始值，也就是dp[0][0]的含义，这里的0并不是字符串索引中的0，只是dp table的一个占位符

```python
   def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        """
        m = len(text1)
        n = len(text2)
        dp = [[0]*(n+1) for i in range(m+1)]
        for i in range(1,m+1):
            for j in range(1,n+1):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        
        return dp[m][n]
```



## 总结

个人理解，如果一个题目涉及到子字符串，而且感觉无法通过一次遍历解决的，都需要上动态规划，这类只能多刷

这道LCS(long common string)是动态规划的经典题目，主要的注意点有两个：

1. dp二维数组的设置，这里把dp二维数组的第0行和第0列都设为初始的占位符，和字符串的索引有一个`错位`,这种个很重要，否则题目中无法完成dp[i-1]这种操作的取值
2. 同上，由于dp table的第0位是占位用的，故两层循环的开始是从1这个数字开始的，而取字符串的元素时，则固定取[i-1],这也是因为dp table的移位
3. dp table的初始化，在python中这个二维数组的长和宽，哪个是m哪个是n要想好，这块比较绕，需要自己体会，本文中采用dp[m]\[n]的取值方式，则需要在初始化dp时，小数组长度为n+1，大数组长度为m+1