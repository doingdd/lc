# 300. 最长递增子序列



## case

```python
case = [
  [10,9,2,5,3,7,101,18],
  [10,9,2,5,3,7,101,18],[7,7,7,7,7,7,7]
  [],
  [1],
  [3,2,1],
  [1,1,0,0]
]
```



## 思路

一次遍历解决不了的，往动态规划上靠拢，这道题使用动态规划，主要需要找到两个点：

base case，就是最小问题，决定了dp 数组里面存放的东西是啥，这道题的base case比较容易想到的是：截止到当前元素，前面的最长递增子序列的长度，但是这个base case不能解决状态转移的问题，如何从前一个元素，推到出当前元素的最长递增子序列长度？有好多种情况需要考虑，比如当前元素与每一个之前的元素作比较，大于还是小于，怎么增加等等

而真正的解法的base case：**以当前元素**为终点的序列，它的最长递增子序列的长度，这个base case要求了子序列必须以当前节点为终点，也就是必须包含当前节点，这样，在状态转移，也就是推到下一个元素的时候，只要比较下一个元素与前一个元素的大小即可处理子序列长度是不是加1的问题

base case找到了之后，状态转移的方式：使用另一个指针j遍历i之前的dp table，找到一个元素比i小的，直接把i拼接到这个子序列的后面，也就是长度+1就是dp[i]的值，如果有多个元素比i小，那么就取最大值

```python
def lenOFLIS(nums):
    n = len(nums)
    if not n:
        return 0

    dp = [1]*n
    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i],dp[j] + 1)

    return max(dp)

for i in case:
    print "case is {0},result is {1}".format(i,lenOFLIS(i))

```



## 总结

这道题是一维动态规划，代码很简单，但是思路很复杂，很难凭借自己的思路解答出n^2的时间复杂度，有三点需要注意：

1. dp数组初始值，由于每个元素都相当于自己的子序列，所以初始值，或者说最差的结果，是子序列长度为1
2. dp 数组 存什么？一般来说，题目问什么就存什么，只不过这里有一个弯，存的是以当前元素为结尾的子序列的长度
3. 怎么推导(转移)，重点再二次遍历的时候做什么，本题中，二次遍历，其实是拿到前面所有元素结尾的子序列最大值，+1即完成推导