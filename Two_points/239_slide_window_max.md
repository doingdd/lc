# [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

## case

```python
k = 3
case = (
[ -1,1,3,4,8,-14],
[1,23,4,2,3,4,5,6,12,2,1,1],
[1,1,1,1,1,1],
[0],
[],
[9,8,7,6,5,4,3,2,1,0,0],
[0,1,2,3,4,5,4,3,2,1,10]
)
```

**示例 1：** 

```python
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7


```

## 思路

本题是要求求一个滑动窗口内的局部最大值，可以使用一个k个元素大顶堆来实现，通过再遍历的过程中维护这个堆，堆顶元素是最大值，同时在`滑动`的过程中将划过的元素从堆中删除。难点就在于如何删除，可以在堆中存储一个元组(index,value),通过index就可以找到想要删除的元素。

更进一步的解法，是用一个双端队列来完成类似大顶堆的功能，能使用双端队列的一个前提，也是本题隐含的特性是：在滑动的过程中，局部的极大值不会立即退出窗口(除非窗口长度为1，也是本题需要特殊处理的）；利用这个特性，将双端队列打造成一个非递增的队列，也就是左侧元素一定大于等于右侧的元素，这样q[0]就一定是极大值，类似于大顶堆中的顶

代码的核心需要维护三个点：

1.  双指针，分别指向滑动窗口的头和尾，刚开始时有一个建立窗口的过程
2. 非递减的双端队列的维护，每遇到新元素时，都判断该元素和队列末尾元素的大小，如果该元素大于队尾元素，就pop队尾元素知道小于等于或者队列为空为止，保证队列`非递增`
3. 由于有2的顺序保证，当滑动窗口达到题目要求的k的长度时，直接将队头元素赋值到答案中即可；同时判断窗口要划出去的元素是不是就是队列中的最大值，如果是的话就popleft更新队列

```python
class Solution(object):
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        from collections import deque
        q = deque()
        i = 0
        res = []
        for j,v in enumerate(nums):
            while q and q[-1] < v:
                q.pop()
            q.append(v)
            if j-i >= k-1:
                res.append(q[0])
                if q[0] == nums[i]:
                    q.popleft()
                
                i += 1
        
        return res 
```

## 总结

本题的思路比较复杂，涉及到局部求极值时一般考虑堆的特点，本题解法属于特殊型，使用队列完成了类似堆的功能，还省去了堆的维护的时间开销，所以时间复杂度降到了O(n)，算是比较典型的一个思路复杂，代码简单的题目。

核心记忆点：

1. 双指针
2. 双端队列的维护，非递增
3. 窗口滑动起来之后的处理，q[0]是答案，同时也在滑动的过程中被更新