## 31.下一个排列

测试驱动开发，先设计用例，后开发代码

### 用例设计

* 有效等价类: [4,5,3,1,2,6],[1,2,3,4],[4,3,2,1]
* 无效等价类:[],[1],[2,2],[1,1,1]
* 特殊情况: [1,1,2,1,1], [3,2,1,6,5,4],[0],[-1,-2,-3]

```
case = ([4,5,2,6,3,1],
        [1,2,3],
        [3,2,1],
        [],
        [1],
        [2,2],
        [1,1,1],
        [1,1,2,1,1],
        [3,2,1,6,5,4],
        [0],
        [-1,-2,-3]
        )
for i in case:
  print i,next_list(i)
```



### 思路

首先理解**下一个排列**的含义，比如拿[1,2,3]举例，它所有的排列为：
```python
[1,2,3]
[1,3,2]
[2,1,3]
[2,3,1]
[3,1,2]
[3,2,1]
```
比如`[2,1,3]`的下一个排列为`[2,3,1]`, 有点像数学里的排列组合知识，这里提炼出下一个排列的两个性质：

1. 下一个排列比前一个组成的数字要大
2. 同时下一个排列是所有比前一个排列组成数字大的组合里，最小的一个，也就是”大“的幅度最小

根据这两个性质，可以具体成两步：

以`[4,5,2,6,3,1]`为例，下一个排列为`[4,5,3,1,2,6]`

1. 先从后往前，找到第一个出现降序的元素，这里为2
2. 再从后往前，找到第一个比2大的元素，这个元素一定是”变大幅度"最小的，因为2的后面都是降序(6,3,1), 这里为3
3. 交换这两个元素，2和3，交换后，变成[4,5,3,6,2,1]
4. 再把原来2位置，也就是新的3的位置之后的元素，按照升序排列，得到[4,5,3,1,2,6]

```python
#!/usr/bin/python
# encoding: utf-8
def next_list(nums):
  l = len(nums)
  if l < 2:
      return nums

  i = l - 2
  ##第一次从后向前遍历，找到i
  while i >= 0:
    if nums[i] < nums[i+1]:
      break
    i -= 1
  ##如果找到了i就继续第二次遍历，如果没有找到，说明数组本身已经是降序了，就没必要第二次遍历了，直接输出倒序排列后的数组
  if i >= 0:
    j = l - 1
    while j > i:
      if nums[j] > nums[i]:
        break

      j -= 1

      nums[i],nums[j] = nums[j],nums[i]
  ## 如果找到i，则把i后面的数组重新排序，如果没有，则把整个数组重新排序
  nums[i+1:] = nums[i::-1] if i >=0 else nums[::-1]

  return nums
```





### 总结

这个题目的关键，在于抽象出`下一个排列`的特性，即，两次遍历：第一次遍历出第一个降序的元素，第二次遍历出第一个比其大的元素
